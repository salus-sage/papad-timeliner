const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const runAll = require('npm-run-all');
const emoji = require('node-emoji');
const StreamLineWrapper = require('stream-line-wrapper');
const PassThrough = require('stream').PassThrough;
const exitHook = require('exit-hook');
const liveServer = require('@pattern-lab/live-server');
const liveServerParams = require('@fesk/live-server-plugin');
const metalsmithConfig = require('metalsmith-config-fesk');
const allMetalsmithConfigs = require('metalsmith-config-fesk/config/all');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const MetalsmithWebpackPlugin = require('@fesk/plugin-metalsmith');
const webpack = require('webpack');
const camelCase = require('lodash.camelcase');
const babelDir = require('@babel/cli/lib/babel/dir');
const PrettyError = require('pretty-error');
const detect = require('detect-port');
const pe = new PrettyError();
const pkg = require('../../../package.json');

pe.skipPackage('loader-runner', 'tapable', 'webpack', 'neo-async');
pe.skipNodeFiles();
pe.skipPath('internal/process/next_tick.js');

const LIVE_SERVER_PORT = process.env.LIVE_SERVER_PORT;

const state = { hasError: false, disableHooks: false };

const hooks = {
  AFTER_INCREMENTAL_WEBPACK: 'afterIncrementalWebpack',
  AFTER_WEBPACK: 'afterWebpack',
  AFTER_BUILD: 'afterBuild',
  AFTER_METALSMITH: 'afterMetalsmith',
  AFTER_BABEL: 'afterBabel',
};

async function callHook(hookName, args) {
  if (state.disableHooks) {
    return null;
  }
  try {
    const customHooks = require(require.resolve(
      path.join(process.cwd(), `fesk.hooks.js`)
    ));

    if (customHooks.hasOwnProperty(hookName)) {
      try {
        return await Promise.resolve(
          customHooks[hookName](msg => {
            log('fishing_pole_and_fish', msg, 'custom hook');
          }, ...args)
        );
      } catch (err) {
        log(
          'fishing_pole_and_fish',
          `${chalk.blue('Hook')} "${hookName}" finished with ${chalk.red(
            'error'
          )}`,
          'hooks'
        );
        console.log(err);
      }
    }
  } catch (err) {
    state.disableHooks = true;
    return null;
  }
}

async function buildMetalsmith(opts) {
  const startTime = Date.now();

  await metalsmithConfig(opts).catch(err => {
    log(
      'x',
      `${chalk.blue('Metalsmith')} finished with ${chalk.red('errors')}`,
      'metalsmith'
    );
    console.log(err);
  });

  await callHook(hooks.AFTER_METALSMITH, [opts]);

  log(
    'hammer',
    `${chalk.green('✔︎')} Done ${chalk.blue('templates')} in ${Date.now() -
      startTime}ms`,
    'metalsmith'
  );
}

async function buildWebpack(webpackConfig, options, customEmoji) {
  const config = Object.assign(
    {
      watch: false,
    },
    options
  );
  const compiler = webpack(webpackConfig);

  if (config.watch) {
    compiler.watch(
      {
        aggregateTimeout: 200,
      },
      (err, stats) => {
        if (err) {
          console.log(pe.render(err));
          return;
        }

        if (stats.compilation.errors && stats.compilation.errors.length) {
          log(
            customEmoji || 'package',
            `${chalk.red('✖')} Done with ${chalk.red(
              stats.compilation.errors.length
            )} errors`,
            'webpack'
          );
          stats.compilation.errors.forEach(error =>
            console.log(pe.render(error))
          );
          return;
        }

        callHook(hooks.AFTER_INCREMENTAL_WEBPACK, [
          webpackConfig,
          config,
          stats,
          compiler,
        ]);

        log(
          customEmoji || 'package',
          `${chalk.green('✔︎')} Done ${chalk.blue(
            'Webpack'
          )} in ${stats.endTime - stats.startTime}ms`,
          'webpack'
        );
      }
    );
  } else {
    const statistics = await new Promise((resolve, error) => {
      compiler.run((err, stats) => {
        if (err) {
          error(err);
          return;
        }
        resolve(stats);
      });
    });

    if (statistics.compilation.errors && statistics.compilation.errors.length) {
      log(
        customEmoji || 'package',
        `${chalk.red('✖')} Done with ${chalk.red(
          statistics.compilation.errors.length
        )} errors`,
        'webpack'
      );

      throw statistics.compilation.errors.pop();
    }

    await callHook(hooks.AFTER_WEBPACK, [
      webpackConfig,
      config,
      statistics,
      compiler,
    ]);

    log(
      customEmoji || 'package',
      `${chalk.green('✔︎')} Done ${chalk.blue(
        'Webpack'
      )} in ${statistics.endTime - statistics.startTime}ms`,
      'webpack'
    );
  }
}

async function buildAssets(scripts = {}, options = {}) {
  if (options.watch === false && scripts['build:assets']) {
    log('package', `Building ${chalk.blue('assets')}`, 'npm-scripts');
    return await runNpmScript('build:assets');
  }
  if (options.watch === true && scripts['watch:assets']) {
    log('package', `Building ${chalk.blue('assets')}`, 'npm-scripts');
    return await runNpmScript('watch:assets');
  }

  log('package', `Building ${chalk.blue('assets')}`, 'webpack');
  return await buildWebpack(getWebpackConfig(), options);
}

async function buildUmd(packageName, scripts = {}, options = {}) {
  if (options.watch === false && scripts['build:umd']) {
    log(
      'earth_americas',
      `Creating a ${chalk.blue('UMD')} bundle`,
      'npm-scripts'
    );
    return await runNpmScript('build:umd');
  }
  if (options.watch === true && scripts['watch:umd']) {
    log(
      'earth_americas',
      `Creating a ${chalk.blue('UMD')} bundle`,
      'npm-scripts'
    );
    return await runNpmScript('watch:umd');
  }

  log('earth_americas', `Creating a ${chalk.blue('UMD')} bundle`, 'webpack');
  return await buildWebpack(
    getWebpackUmdConfig(packageName, options),
    options,
    'earth_americas'
  );
}

function getWebpackUmdConfig(packageName, options) {
  const umdConfig = getWebpackConfig('umd');
  if (umdConfig) {
    return umdConfig;
  }
  const baseConfig = getWebpackConfig();

  const plugins = baseConfig.plugins
    .map(plugin => {
      if (plugin instanceof MetalsmithWebpackPlugin) {
        return null;
      }
      if (plugin instanceof CleanWebpackPlugin) {
        return new CleanWebpackPlugin({
          cleanOnceBeforeBuildPatterns: ['umd'],
          ...plugin.options,
        });
      }
      return plugin;
    })
    .filter(Boolean);

  return Object.assign({}, baseConfig, {
    output: {
      path: path.resolve(process.cwd(), 'dist', 'umd'),
      filename: `${packageName}.js`,
      libraryTarget: 'umd',
      library: options.library || camelCase(packageName),
      umdNamedDefine: true,
    },
    plugins,
    externals: Object.assign(
      {},
      baseConfig.externals || {},
      options.umd && options.umd.externals ? options.umd.externals : {}
    ),
  });
}

async function buildCjs(scripts = {}, options = {}) {
  if (options.watch === false && scripts['build:cjs']) {
    log(
      'tropical_fish',
      `Creating a ${chalk.blue('CommonJS')} folder`,
      'npm-scripts'
    );
    return await runNpmScript('build:cjs');
  }
  if (options.watch === true && scripts['watch:cjs']) {
    log(
      'tropical_fish',
      `Creating a ${chalk.blue('CommonJS')} folder`,
      'npm-scripts'
    );
    return await runNpmScript('watch:cjs');
  }

  log('tropical_fish', `Creating a ${chalk.blue('CommonJS')} folder`, 'babel');

  if (!options.watch) {
    // Because babel.
    process.stdout.write(
      chalk.gray(
        ` ${emoji.get('tropical_fish')}    babel ${chalk.green('✔︎')} `
      )
    );
  }

  await babelDir.default({
    cliOptions: {
      copyFiles: true,
      outDir: './lib',
      filenames: ['./src'],
      watch: options.watch,
      extensions: options.typescript ? ['.ts', '.tsx'] : ['.js', '.jsx'],
      skipInitialBuild: options.watch,
    },
    babelOptions: {
      presets: [
        [
          'module:@fesk/babel-config',
          {
            absoluteRuntime: false,
            typescript: options.typescript,
          },
        ],
      ],
      plugins: [
        [
          'module:@babel/plugin-transform-modules-commonjs',
          { noInterop: false },
        ],
      ],
    },
  });

  await callHook(hooks.AFTER_BABEL, [options]);
}

function getWebpackConfig(variation = '') {
  if (variation) {
    try {
      return require(require.resolve(
        path.join(process.cwd(), `webpack.${variation}.js`)
      ));
    } catch (err) {
      return null;
    }
  }

  return require(require.resolve(
    path.join(process.cwd(), 'webpack.config.js')
  ));
}

function getConfiguration(cwd) {
  // Where do we need configuration from?
  // allMetalsmithConfigs
  const moduleConfigs = allMetalsmithConfigs.reduce((allConfigs, config) => {
    const configLoc = path.join(cwd, 'src', config.path, 'config.json');
    if (fs.existsSync(configLoc)) {
      try {
        allConfigs[config.name] = require(configLoc);
      } catch (err) {}
    }
    return allConfigs;
  }, {});

  const packageJson = getPackageJson(cwd);

  return {
    ...moduleConfigs,
    ...(packageJson.fesk || {}),
  };
}

async function buildTemplates(scripts = {}, config = {}) {
  const options = { ...config, ...(config.metalsmith || {}) };
  if (options.watch === false && scripts['build:templates']) {
    log('hammer', `Building ${chalk.blue('templates')}`, 'npm-scripts');
    return await runAll(['build:templates'], {
      stdout: stdOutWrapper(),
      arguments: '--color',
    });
  }
  if (options.watch === true && scripts['watch:templates']) {
    log('hammer', `Watching ${chalk.blue('templates')}`, 'npm-scripts');
    return await runAll(['watch:templates'], {
      stdout: stdOutWrapper(),
      arguments: '--color',
    });
  }

  log('hammer', `Building ${chalk.blue('templates')}`, 'metalsmith');
  if (options.watch) {
    options.watchConfig = {
      log(t) {
        log('hammer', t, 'metalsmith');
      },
    };
  }

  return await buildMetalsmith(options);
}

async function runNpmScript(script) {
  await runAll([script], {
    stdout: stdOutWrapper(),
  });
}

function onExit(func, onError = false) {
  exitHook(() => {
    if (onError === false && state.hasError) return;
    process.stdout.clearLine(); // clear current text
    console.log('\n');
    func();
  });
}

async function startLiveServer(port) {
  await new Promise(async resolve => {
    const portToTry = LIVE_SERVER_PORT || port || 5000;
    const portToUse = await detect(portToTry);

    if (portToTry !== portToUse) {
      log(
        'fire',
        chalk.yellow(
          `Port ${portToTry} was unavailable, using port ${portToUse}`
        ),
        'live server'
      );
    }

    log(
      'fire',
      `Started server at ${chalk.blue(`http://localhost:${portToUse}`)}`,
      'live server'
    );
    const params = {
      ...liveServerParams,
    };
    params.port = portToUse;
    liveServer.start(params);
    resolve();
  });
}

function run(callable, options = {}) {
  (async () => {
    try {
      await callable(options);
    } catch (err) {
      tableFoot(() => log('x', 'Something went wrong'));
      state.hasError = true;
      console.log('');
      console.log(pe.render(err));
      console.log('');
      process.exit(1);
    }
  })();
}

function stdOutWrapper() {
  const stream = new PassThrough();
  stream
    .pipe(
      new StreamLineWrapper({
        // prefix: '    ┃  ',
        wrapper: (line, cb) => {
          if (line.indexOf('$ ') === 0) {
            cb(
              null,
              `${chalk.gray(
                ` ${emoji.get('package')}     npm-scripts`
              )} ${line.slice(2)}`
            );
          } else {
            cb(
              null,
              `${chalk.gray(
                ` ${emoji.get('package')}     npm-scripts`
              )} ${line}`
            );
          }
        },
      })
    )
    .pipe(process.stdout);
  return stream;
}

function log(emote, t, name) {
  console.log(
    chalk.gray(` ${emoji.get(emote)}   ${name ? ' ' + name : ''}`),
    t
  );
}

function isJest() {
  return process.env.JEST_WORKER_ID !== undefined;
}

function banner() {
  console.log('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  console.log(
    `       ${chalk.green('FESK')} Frontend starter kit ${
      isJest() ? '' : chalk.green(`v${pkg.version}`)
    }`
  );
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');
}

function repeat(prefix, strToRepeat) {
  return prefix + strToRepeat.repeat(process.stdout.columns - prefix.length);
}

function getPackageJson(cwd) {
  return JSON.parse(
    fs.readFileSync(path.resolve(path.join(cwd, 'package.json')))
  );
}

function getPackageJsonScripts(cwd) {
  const packageJson = getPackageJson(cwd);
  return packageJson.scripts || {};
}

function tableTop(callable) {
  console.log('\n');
  callable();
  console.log('\n');
}

function tableFoot(callable) {
  console.log('\n');
  callable();
}

function tableMiddle(callable) {
  console.log('\n');
  callable();
  console.log('\n');
}

module.exports = {
  buildAssets,
  buildUmd,
  buildCjs,
  buildTemplates,
  banner,
  repeat,
  run,
  log,
  getPackageJson,
  getConfiguration,
  onExit,
  startLiveServer,
  runNpmScript,
  stdOutWrapper,
  getPackageJsonScripts,
  tableTop,
  tableMiddle,
  tableFoot,
};
