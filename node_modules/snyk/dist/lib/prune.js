"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneGraph = exports.countPathsToGraphRoot = void 0;
const _debug = require("debug");
const dep_graph_1 = require("@snyk/dep-graph");
const config = require("./config");
const errors_1 = require("./errors");
const analytics = require("../lib/analytics");
const debug = _debug('snyk:prune');
const { depTreeToGraph, graphToDepTree } = dep_graph_1.legacy;
function countPathsToGraphRoot(graph) {
    return graph
        .getPkgs()
        .reduce((acc, pkg) => acc + graph.countPathsToRoot(pkg), 0);
}
exports.countPathsToGraphRoot = countPathsToGraphRoot;
async function pruneGraph(depGraph, packageManager, pruneIsRequired = false) {
    const prePrunePathsCount = countPathsToGraphRoot(depGraph);
    const isDenseGraph = prePrunePathsCount > config.PRUNE_DEPS_THRESHOLD;
    debug('rootPkg', depGraph.rootPkg);
    debug('prePrunePathsCount: ' + prePrunePathsCount);
    debug('isDenseGraph', isDenseGraph);
    analytics.add('prePrunePathsCount', prePrunePathsCount);
    if (isDenseGraph || pruneIsRequired) {
        const prunedTree = (await graphToDepTree(depGraph, packageManager, {
            deduplicateWithinTopLevelDeps: true,
        }));
        const prunedGraph = await depTreeToGraph(prunedTree, packageManager);
        const postPrunePathsCount = countPathsToGraphRoot(prunedGraph);
        analytics.add('postPrunePathsCount', postPrunePathsCount);
        debug('postPrunePathsCount' + postPrunePathsCount);
        if (postPrunePathsCount > config.MAX_PATH_COUNT) {
            debug('Too many vulnerable paths to process the project');
            throw new errors_1.TooManyVulnPaths();
        }
        return prunedGraph;
    }
    return depGraph;
}
exports.pruneGraph = pruneGraph;
//# sourceMappingURL=prune.js.map